<!DOCTYPE html><html><head><link href="/images/favicon.png" rel="icon" type="image/png" /><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="ROM &raquo; Guides &raquo; Relations via @rom_rb" name="twitter:description" /><meta content="ROM &raquo; Guides &raquo; Relations" name="description" /><title>ROM &raquo; Guides &raquo; Relations</title><style type="text/css">.highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #d0d0d0;
  background-color: #151515;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}</style><link href="../../../stylesheets/all.css" rel="stylesheet" /><script src="../../../javascripts/all.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script><script>$(function() {
  var share = new Share(".share")
});
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-2573270-5', 'auto');
ga('send', 'pageview');</script></head><body class="guides guides_basics guides_basics_relations guides_basics_relations_index"><div class="page-wrapper"><header><nav class="navbar navbar-default navbar-static-top"><div class="navbar-inner"><div class="container"><a class="navbar-brand" href="/">Ruby Object Mapper</a><ul class="nav navbar-nav"><li class=""><a class="" href="/introduction">Introduction</a></li><li class=""><a class="" href="/guides">Guides</a></li><li class=""><a class="" href="/tutorials">Tutorials</a></li><li class="dropdown"><a class="dropdown-toggle" role="button" data-toggle="dropdown" href="#">API Reference <span class='caret'/></a><ul class="dropdown-menu" role="menu"><li><a href="http://www.rubydoc.info/gems/rom">rom</a></li><li><a href="http://www.rubydoc.info/gems/rom-sql">rom-sql</a></li><li><a href="http://www.rubydoc.info/gems/rom-yesql">rom-yesql</a></li><li><a href="http://www.rubydoc.info/gems/rom-influxdb">rom-influxdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-event_store">rom-event_store</a></li><li><a href="http://www.rubydoc.info/gems/rom-rethinkdb">rom-rethinkdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-mongo">rom-mongo</a></li><li><a href="http://www.rubydoc.info/gems/rom-redis">rom-redis</a></li><li><a href="http://www.rubydoc.info/gems/rom-csv">rom-csv</a></li><li><a href="http://www.rubydoc.info/gems/rom-yaml">rom-yaml</a></li><li><a href="http://www.rubydoc.info/gems/rom-dm">rom-dm</a></li><li><a href="http://www.rubydoc.info/gems/rom-lotus">rom-lotus</a></li><li><a href="http://www.rubydoc.info/gems/rom-rails">rom-rails</a></li><li><a href="http://www.rubydoc.info/gems/rom-roda">rom-roda</a></li></ul></li><li class=""><a class="" href="/blog">Blog</a></li><li class=""><a class="" href="/contribute">Contribute</a></li><li class=""><a class="" href="/status">Status</a></li></ul></div></div></nav></header><div class="container"><div class="content"><div class="row"><div class="col-md-3"><ul class="nav nav-pills nav-stacked"><li class="nav-heading"><a class="nav-heading" href="/guides/basics/setup">Setup</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/repositories">Repositories</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/relations">Relations</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/commands">Commands</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/mappers">Mappers</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/adapters">Adapters</a></li><li class=""><a class="" href="/guides/adapters/how-to">How-to</a></li><li class=""><a class="" href="/guides/adapters/sql">SQL</a></li></ul></div><div class="col-md-9"><div class="page-article"><h1 id="relations">Relations</h1>

<p>In bigger applications query logic becomes complicated very quickly. That&rsquo;s why
it is a good idea to break it down into smaller components. You can get pretty
far with <a href="/guides/basics/repositories/">Repositories</a> but eventually you will
face a situation where encapsulating complex query inside custom relations will
be helpful.</p>

<p>In ROM relations are the central part of the system. They provide access to data
through internal interfaces provided by adapters and allow you to specify your
own interface for accessing <em>application-specific data structures</em>.</p>

<p>The fundamental design principle in ROM is that all components work with relations
rather than individual objects from relations. This means that a relation can only
return other relations (also known as &ldquo;views&rdquo;). Then both commands and mappers
receive a relation, do their work and return a relation back.</p>

<h2 id="defining-a-relation">Defining a relation</h2>

<p>A relation can be defined as a class that inherits from an adapter-specific class
which is identified by adapter&rsquo;s name, in case of our example it&rsquo;s <code>:memory</code>:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:memory</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>

<p>Alternatively you can use the routing-style DSL:</p>
<pre class="highlight ruby"><code><span class="no">ROM</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span> <span class="k">do</span>
<span class="k">end</span>
</code></pre>

<p>In a relation you can define a specific <a href="/introduction/glossary/#gateway">gateway</a> and <a href="/introduction/glossary/#dataset">dataset</a> it takes data from, and the registered name of the relation. In the following example the default options are set explicitly:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:memory</span><span class="p">]</span>
  <span class="n">register_as</span> <span class="ss">:users</span>
  <span class="n">gateway</span> <span class="ss">:default</span>
  <span class="n">dataset</span> <span class="ss">:users</span>
<span class="k">end</span>
</code></pre>

<h2 id="interface-boundaries">Interface Boundaries</h2>

<p>Relation layer in ROM clearly establishes interface boundaries. Each relation has
the internal interface provided by the adapter and allow you to define your own
interface that will be accessible in your application layer.</p>

<p>In example:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:memory</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">by_name</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="n">restrict</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>This relation defines public <code>by_name</code> interface that you will be able to use in
your application. This interface uses internal <code>restrict</code> method which is provided
by the in-memory adapter.</p>

<h2 id="lazy-relations">Lazy Relations</h2>

<p>The top-level interface for accessing relations which is exposed by the environment
adds very powerful lazy-relation API which allows you to compose relations together
and send them through the data pipeline.</p>

<h3 id="the-data-pipeline">The Data Pipeline</h3>

<p>You can send a relation through any object that responds to <code>call</code> using common
<code>&gt;&gt;</code> operator:</p>
<pre class="highlight ruby"><code><span class="no">ROM</span><span class="p">.</span><span class="nf">use</span> <span class="ss">:auto_registration</span>

<span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span><span class="ss">:memory</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:memory</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">by_name</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="n">restrict</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span>

<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span>

<span class="n">name_list</span> <span class="o">=</span> <span class="o">-&gt;</span> <span class="n">users</span> <span class="k">do</span>
  <span class="n">users</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="n">user</span><span class="p">[</span><span class="ss">:name</span><span class="p">]</span> <span class="p">}</span>
<span class="k">end</span>

<span class="n">user_names</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">name_list</span>

<span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">to_a</span>
<span class="c1"># [{ id: 1, name: 'Joe', email: 'joe@example.com' }]</span>
<span class="n">user_names</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># ['Joe']</span>
</code></pre>

<h3 id="auto-curry">Auto-curry</h3>

<p>Every relation method that you defined supports auto-curry syntax which simply
means that you can reference a relation without providing method arguments:</p>
<pre class="highlight ruby"><code><span class="n">users_by_name</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">by_name</span>

<span class="c1"># call later on using short `[]` syntax</span>
<span class="n">users_by_name</span><span class="p">[</span><span class="s1">'Jane'</span><span class="p">]</span>

<span class="c1"># or</span>

<span class="n">users_by_name</span><span class="o">.</span><span class="p">(</span><span class="s1">'Jane'</span><span class="p">)</span>

<span class="c1"># or more explicit and longer form</span>
<span class="n">users_by_name</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="s1">'Jane'</span><span class="p">)</span>
</code></pre>

<h3 id="combining-relations">Combining Relations</h3>

<p>Auto-curry and data-pipeline allows very simple yet powerful feature where you
can combine results from many relations into a single relation:</p>
<pre class="highlight ruby"><code><span class="no">ROM</span><span class="p">.</span><span class="nf">use</span> <span class="ss">:auto_registration</span>

<span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span><span class="ss">:memory</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Users</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:memory</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">by_name</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="n">restrict</span><span class="p">(</span><span class="ss">name: </span><span class="nb">name</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Tasks</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:memory</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">for_users</span><span class="p">(</span><span class="n">users</span><span class="p">)</span>
    <span class="n">restrict</span><span class="p">(</span><span class="ss">user_id: </span><span class="n">users</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">u</span><span class="o">|</span> <span class="n">u</span><span class="p">[</span><span class="ss">:id</span><span class="p">]</span> <span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span>

<span class="n">users</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">)</span>
<span class="n">tasks</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:tasks</span><span class="p">)</span>

<span class="c1"># combine two relations into one</span>
<span class="n">users</span><span class="p">.</span><span class="nf">by_name</span><span class="p">(</span><span class="s1">'Jane'</span><span class="p">).</span><span class="nf">combine</span><span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="nf">for_users</span><span class="p">)</span>
</code></pre>

<p>As you can probably imagine this allows combining relations across different
datastores.</p>

<h3 id="loaded-relations">Loaded Relations</h3>

<p>A lazy relation can be materialized into a loaded relation by calling it. There
are few methods that triggers calling a lazy relation too:</p>
<pre class="highlight ruby"><code><span class="n">users</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">by_name</span><span class="p">(</span><span class="s1">'Jane'</span><span class="p">)</span>

<span class="n">loaded</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">call</span> <span class="c1"># returns a loaded relation</span>

<span class="n">loaded</span><span class="p">.</span><span class="nf">source</span> <span class="c1"># returns users</span>
<span class="n">loaded</span><span class="p">.</span><span class="nf">collection</span> <span class="c1"># returns materialized users array with tuples</span>
</code></pre>

<h3 id="accessing-a-single-tuple">Accessing a Single Tuple</h3>

<p>If you want to retrieve a single tuple from a relation you can use either <code>one</code>
or <code>one!</code> which is an intention-revealing interface resulting in an exception
when a relation includes more than one tuple.</p>
<pre class="highlight ruby"><code><span class="c1"># return one tuple or raise error if there's no tuples</span>
<span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">one</span>

<span class="c1"># return one tuple or raise error if there's no tuples or more than one</span>
<span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:users</span><span class="p">).</span><span class="nf">one!</span>
</code></pre>
<div class="page-article-edit"><hr /><div class="share pull-left"></div><p class="pull-right">Edit this article on <a href="https://github.com/rom-rb/rom-rb.org/tree/master/source/doc-pages.md">GitHub</a></p></div></div></div></div></div></div></div><footer><div class="container"><div class="social"><div class="github"><iframe allowtransparency="true" frameborder="0" height="20" scrolling="0" src="http://ghbtns.com/github-btn.html?user=rom-rb&repo=rom&type=watch&count=true" width="110"></iframe></div><div class="twitter"><a class="twitter-follow-button" data-show-count="true" data-show-screen-name="false" href="https://twitter.com/rom_rb">Follow</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></div></div><div class="muted copyright">Ruby Object Mapper &copy; 2014-2015</div></div></footer></body></html>